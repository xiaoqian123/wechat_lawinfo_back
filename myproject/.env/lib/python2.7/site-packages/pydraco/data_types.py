#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
python 的数据类型和postgres的数据类型的转换
'''

from collections import defaultdict
from struct import pack, Struct
import json
import datetime 
from calendar import timegm
from decimal import Decimal
import types
from six import b
from message_types import *
from .error import *

import oid

FC_TEXT = 0
FC_BINARY = 1

TRUE = b("\x01")
FALSE = b("\x00")


ZERO = datetime.timedelta(0)

class UTC(datetime.tzinfo):

    def utcoffset(self, dt):
        return ZERO

    def tzname(self, dt):
        return "UTC"

    def dst(self, dt):
        return ZERO


utc = UTC()

EPOCH = datetime.datetime(2000, 1, 1)
EPOCH_TZ = EPOCH.replace(tzinfo=utc)
EPOCH_SECONDS = timegm(EPOCH.timetuple())
INFINITY_MICROSECONDS = 2 ** 63 - 1
MINUS_INFINITY_MICROSECONDS = -1 * INFINITY_MICROSECONDS - 1

def pack_funcs(fmt):
    struc = Struct('!' + fmt)
    return struc.pack, struc.unpack_from

i_pack, i_unpack = pack_funcs('i')
h_pack, h_unpack = pack_funcs('h')
q_pack, q_unpack = pack_funcs('q')
d_pack, d_unpack = pack_funcs('d')
f_pack, f_unpack = pack_funcs('f')
iii_pack, iii_unpack = pack_funcs('iii')
ii_pack, ii_unpack = pack_funcs('ii')
qii_pack, qii_unpack = pack_funcs('qii')
dii_pack, dii_unpack = pack_funcs('dii')
ihihih_pack, ihihih_unpack = pack_funcs('ihihih')
ci_pack, ci_unpack = pack_funcs('ci')
bh_pack, bh_unpack = pack_funcs('bh')
cccc_pack, cccc_unpack = pack_funcs('cccc')


min_int2, max_int2 = -2 ** 15, 2 ** 15
min_int4, max_int4 = -2 ** 31, 2 ** 31
min_int8, max_int8 = -2 ** 63, 2 ** 63

###
# PG_type to Python type
###

def text_recv(data, offset, length):
    return unicode(data[offset: offset + length], 'utf8')

def bool_recv(data, offset, length):
    return data[offset] == "\x01"

def array_recv(data, idx, length):
    final_idx = idx + length
    dim, hasnull, typeoid = iii_unpack(data, idx)
    idx += 12

    # get type conversion method for typeoid
    conversion = self.pg_types[typeoid][1]

    # Read dimension info
    dim_lengths = []
    for i in range(dim):
        dim_lengths.append(ii_unpack(data, idx)[0])
        idx += 8

    # Read all array values
    values = []
    while idx < final_idx:
        element_len, = i_unpack(data, idx)
        idx += 4
        if element_len == -1:
            values.append(None)
        else:
            values.append(conversion(data, idx, element_len))
            idx += element_len

    # at this point, {{1,2,3},{4,5,6}}::int[][] looks like
    # [1,2,3,4,5,6]. go through the dimensions and fix up the array
    # contents to match expected dimensions
    for length in reversed(dim_lengths[1:]):
        values = list(map(list, zip(*[iter(values)] * length)))
    return values

def float4_recv(data, offset, length):
    return f_unpack(data, offset)[0]

def float8_recv(data, offset, length):
    return d_unpack(data, offset)[0]

def int8_recv(data, offset, length):
    return q_unpack(data, offset)[0]

def int2_recv(data, offset, length):
    return h_unpack(data, offset)[0]

def int4_recv(data, offset, length):
    return i_unpack(data, offset)[0]

def json_in(data, offset, length):
    return json.loads(unicode(data[offset: offset + length], 'utf8'))

def date_in(data, offset, length):
    d = data[offset:offset+length].decode(self._client_encoding)
    try:
        return date(int(d[:4]), int(d[5:7]), int(d[8:10]))
    except ValueError:
        return d

def time_in(data, offset, length):
    hour = int(data[offset:offset + 2])
    minute = int(data[offset + 3:offset + 5])
    sec = Decimal(
        data[offset + 6:offset + length].decode(self._client_encoding))
    return time(hour, minute, int(sec), int((sec - int(sec)) * 1000000))

# data is double-precision float representing seconds since 2000-01-01
def timestamp_recv_float(data, offset, length):
    return datetime.datetime.utcfromtimestamp(EPOCH_SECONDS + d_unpack(data, offset)[0])

def timestamptz_recv_float(data, offset, length):
    return timestamp_recv_float(data, offset, length).replace(tzinfo=utc)


def array_in(data, idx, length):
    arr = []
    prev_c = None
    for c in data[idx:idx+length].decode('utf8').translate(trans_tab).replace(u('NULL'), u('None')):
        if c not in ('[', ']', ',', 'N') and prev_c in ('[', ','):
            arr.extend("Decimal('")
        elif c in (']', ',') and prev_c not in ('[', ']', ',', 'e'):
            arr.extend("')")

        arr.append(c)
        prev_c = c
    return eval(''.join(arr), glbls)

def null_send(v):
    return None

def bool_send(v):
    if v:
        return TRUE
    else:
        return FALSE

def int2_send(v):
    return h_pack(v)

def int4_send(v):
    return i_pack(v)

def int8_send(v):
    return q_pack(v)

def text_send(v):
    if v:
        if isinstance(v, str):
            return v
        elif isinstance(v, unicode):
            return v.encode('utf8')
        else:
            return str(v)
    else:
        return ''

def json_send(v):
    pass

def float_send(v):
    return d_pack(v)

def timestamp_send(v):
    pass

def make_params(parameters):
    params = []

    for v in parameters:

        if isinstance(v, types.StringType):
            typ = types.StringType
        elif isinstance(v, types.UnicodeType):
            typ = types.UnicodeType
        else:
            typ = type(v)

        try:
            params.append(py_types[typ] + (v,))
        except KeyError:
            try:
                params.append(inspect_funcs[typ](v) + (v,))
            except KeyError as e:
                raise NotSupportedError("type " + str(e) + "not mapped to pg type")
    return tuple(params)

def inspect_array(v):
    pass

def inspect_datetime(value):
    if value.tzinfo is None:
        return self.py_types[1114]  # timestamp
    else:
        return self.py_types[1184]  # send as timestamptz


def inspect_int(value):
    if min_int2 < value < max_int2:
        return py_types[oid.INT2]
    if min_int4 < value < max_int4:
        return py_types[oid.INT4]
    if min_int8 < value < max_int8:
        return py_types[oid.INT8]

pg_types = defaultdict(
        lambda: (FC_TEXT, text_recv), {
            oid.BOOL: (FC_BINARY, bool_recv),  # boolean
            oid.INT8: (FC_BINARY, int8_recv),  # int8
            oid.INT2: (FC_BINARY, int2_recv),  # int2
            oid.INT4: (FC_BINARY, int4_recv),  # int4
            oid.JSON: (FC_TEXT, json_in),  # json
            oid.FLOAT4: (FC_BINARY, float4_recv),  # float4
            oid.FLOAT8: (FC_BINARY, float8_recv),  # float8
            oid.BOOL_ARRAY: (FC_BINARY, array_recv),  # BOOL[]
            oid.INT2_ARRAY: (FC_BINARY, array_recv),  # INT2[]
            oid.INT4_ARRAY: (FC_BINARY, array_recv),  # INT4[]
            oid.VARCHAR_ARRAY: (FC_BINARY, array_recv),  # VARCHAR[]
            oid.INT8_ARRAY: (FC_BINARY, array_recv),  # INT8[]
            oid.FLOAT4_ARRAY: (FC_BINARY, array_recv),  # FLOAT4[]
            oid.FLOAT8_ARRAY: (FC_BINARY, array_recv),  # FLOAT8[]
            oid.VARCHAR: (FC_BINARY, text_recv),  # VARCHAR type
            oid.TIMESTAMPTZ: (FC_BINARY, timestamptz_recv_float),
            })

py_types = {
            types.NoneType: (oid.UNSPECIFIED, FC_TEXT, null_send),  # null
            types.StringType: (oid.VARCHAR, FC_TEXT, text_send),  
            types.UnicodeType: (oid.VARCHAR, FC_TEXT, text_send),  
            types.BooleanType: (oid.BOOL, FC_BINARY, bool_send),
            types.DictType: (oid.JSON, FC_TEXT, json_send),
            types.LongType: (oid.INT8, FC_TEXT, text_send),
            types.FloatType: (oid.FLOAT8, FC_BINARY, float_send),
            Decimal: (oid.FLOAT8, FC_BINARY, float_send),
            datetime.date: (oid.TIMESTAMPTZ, FC_BINARY, timestamp_send),
            datetime.datetime: (oid.TIMESTAMPTZ, FC_BINARY, timestamp_send),
            }  

# INT类型, 由inspect_int确定
py_types[oid.INT2] = (oid.INT4, FC_BINARY, int4_send)
py_types[oid.INT4] = (oid.INT4, FC_BINARY, int4_send)
py_types[oid.INT8] = (oid.INT4, FC_BINARY, int4_send)



inspect_funcs = {
        list: inspect_array,
        tuple: inspect_array,
        int: inspect_int
        }
