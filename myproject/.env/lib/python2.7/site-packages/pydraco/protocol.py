#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Postgres frontend/backend 通信协议
'''


import logging
from six import b
from struct import pack, Struct
import io

import message_types as mt 

logger = logging.getLogger(__name__)

NULL = b('\xff\xff\xff\xff')
NULL_BYTE = b('\x00')


def write_char(stream, char):
    stream.write(pack('c', char))

def write_int4(stream, i4):
    stream.write(pack('!i', i4))

def write_int2(stream, i2):
    stream.write(pack('!h', i2))

def write_buf(stream, buf):
    stream.write(buf)

def write_null(stream):
    write_char(stream, NULL_BYTE)

def write_string(stream, s):
    write_buf(stream, s)
    write_null(stream)

def build_startup_msg(params):
    message = io.BytesIO()
    encoded_size = 4 + 4 

    assert isinstance(params, dict)

    for k,v in params.iteritems():
        encoded_size += len(k) + 1
        encoded_size += len(v) + 1

    write_int4(message, encoded_size)
    write_int4(message, 196608)

    for k,v in params.iteritems():
        write_string(message, k)
        write_string(message, v) 

    return message.getvalue() 

def build_query_msg(query):
    message = io.BytesIO()
    encoded_size = 4 + len(query) + 1 

    write_char(message, mt.QUERY)
    write_int4(message, encoded_size)
    write_string(message, query)

    return message.getvalue() 

def build_parse_msg(stmt, query, params):
    message = io.BytesIO()

    encoded_size = 4 + len(stmt) + 1 \
                     + len(query) + 1 \
                     + 2 + len(params) * 4
    
    write_char(message, mt.PARSE)
    write_int4(message, encoded_size)

    #The name of the destination prepared statement (an empty string selects the unnamed prepared statement).
    write_string(message, stmt)
    #The query string to be parsed.
    write_string(message, query)

    """
    The number of parameter data types specified (can be zero). 
    Note that this is not an indication of the number of parameters that might appear in the query string, 
    only the number that the frontend wants to prespecify types for.  
    """
    write_int2(message, len(params))

    """
    Then, for each parameter, there is the following:

        Int32
        Specifies the object ID of the parameter data type. Placing a zero here is equivalent to leaving the type unspecified.
    """ 
    for p in params:
        write_int4(message, p[0])

    return message.getvalue() 

def build_bind_msg(portal, stmt, params):
    # Total size = 4 (size field) + N + 1 (destination portal)
    # + N + 1 (statement name)
    # + 2 (param format code count) + N * 2 (format codes)
    # + 2 (param value count) + N * 4 (encoded param value size) + N
    # + 2 (result format code count, 0)
    message = io.BytesIO()

    encoded_size = 4  + len(portal) + 1  \
                      + len(stmt) + 1  \
                      + 2 + len(params) * 2 \
                      + 2 \
                      + 2 + 2

    p_values = []
    for p in params:
        encoded_size += 4
        send_func = p[2]
        value = p[-1]
        buf = send_func(value)
        if buf is not None:
            encoded_size += len(buf)
        p_values.append(buf)

    write_char(message, mt.BIND)
    write_int4(message, encoded_size)
    write_string(message, portal)
    write_string(message, stmt)

    """
    The number of parameter format codes that follow (denoted C below). 
    This can be zero to indicate that there are no parameters or that the parameters all use the default format (text); 
    or one, in which case the specified format code is applied to all parameters;
    or it can equal the actual number of parameters.
    """
    write_int2(message, len(params))

    """
    Int16[C]
    The parameter format codes. Each must presently be zero (text) or one (binary).
    """
    for p in params:
        write_int2(message, p[1])

    """
    Int16
        The number of parameter values that follow (possibly zero). This must match the number of parameters needed by the query.
    """
    write_int2(message, len(params))

    """
    Int32
        The length of the parameter value, in bytes (this count does not include itself). 
        Can be zero. As a special case, -1 indicates a NULL parameter value.  
        No value bytes follow in the NULL case.
    Byten
        The value of the parameter, in the format indicated by the associated format code. n is the above length.
    """
    for v in p_values:
        if v is None:
            write_int4(message, -1)
        else:
            write_int4(message, len(v))
            write_buf(message, v)

    """
    After the last parameter, the following fields appear:

    Int16
    The number of result-column format codes that follow (denoted R below). This can be zero to indicate that there are no result columns or that the result columns should all use the default format (text); or one, in which case the specified format code is applied to all result columns (if any); or it can equal the actual number of result columns of the query.

    Int16[R]
    The result-column format codes. Each must presently be zero (text) or one (binary).
    """
    write_int2(message, 1)
    write_int2(message, 1)

    return message.getvalue() 

def build_describe_portal(portal):
    return build_describe_msg('P', portal)

def build_describe_stmt(stmt):
    return build_describe_msg('S', stmt)

def build_describe_msg(describe_type, describe_value):
    message = io.BytesIO()
    encoded_size = 4  + 1 + len(describe_value) + 1

    write_char(message, mt.DESCRIBE)
    write_int4(message, encoded_size)

    #'S' to describe a prepared statement; or 'P' to describe a portal.
    write_char(message, describe_type)
    write_string(message, describe_value)

    return message.getvalue() 

def build_execute_msg(portal, max_rows=0):
    message = io.BytesIO()
    encoded_size = 4  + len(portal) + 1 + 4

    write_char(message, mt.EXECUTE)
    write_int4(message, encoded_size)
    #The name of the portal to execute (an empty string selects the unnamed portal).
    write_string(message, portal)
    #Maximum number of rows to return, if portal contains a query that returns rows (ignored otherwise). Zero denotes “no limit”.
    write_int4(message, max_rows)

    return message.getvalue() 

def build_sync_msg():
    message = io.BytesIO()
    encoded_size = 4  

    write_char(message, mt.SYNC)
    write_int4(message, encoded_size)

    return message.getvalue() 

def build_terminate_msg():
    message = io.BytesIO()
    encoded_size = 4  

    write_char(message, mt.EXECUTE)
    write_int4(message, encoded_size)

    return message.getvalue() 

def build_close_portal(portal):
    return build_close_msg('P', portal)

def build_close_stmt(stmt_name):
    return build_close_msg('S', stmt_name)

def build_close_msg(close_type, close_val):
    message = io.BytesIO()
    encoded_size = 4  + 1 + len(close_val) + 1

    write_char(message, mt.CLOSE)
    write_int4(message, encoded_size)

    #'S' to close a prepared statement; or 'P' to close a portal.
    write_char(message, close_type)
    write_string(message, close_val)

    return message.getvalue() 

def build_flush_msg():
    message = io.BytesIO()
    encoded_size = 4  

    write_char(message, mt.FLUSH)
    write_int4(message, encoded_size)

    return message.getvalue() 


