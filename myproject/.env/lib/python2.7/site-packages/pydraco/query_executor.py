#!/usr/bin/env python
# -*- coding: utf-8 -*-


import logging
from collections import deque, defaultdict, OrderedDict
from six import b, binary_type, text_type, itervalues
import binascii 

from message_types import *
from error import (Error, InterfaceError, DatabaseError, OperationalError, 
        NotSupportedError, IntegrityError, InternalError, 
        ProgrammingError,  NotSupportedError)
import data_types as dt
import protocol

logger = logging.getLogger(__name__)

_commands_with_count = ( b("INSERT"), b("DELETE"), b("UPDATE"), b("MOVE"), b("FETCH"), b("COPY"), b("SELECT"))

class QueryExecutor(object):
    QUERY_ONESHOT = 1

    def __init__(self, connection):
        self._c = connection
        self.next_unique_id = 0

        self.message_handles = {
            NOTICE_RESPONSE: self.handle_NOTICE_RESPONSE,
            AUTHENTICATION_REQUEST: self.handle_AUTHENTICATION_REQUEST,
            PARAMETER_STATUS: self.handle_PARAMETER_STATUS,
            BACKEND_KEY_DATA: self.handle_BACKEND_KEY_DATA,
            READY_FOR_QUERY: self.handle_READY_FOR_QUERY,
            ROW_DESCRIPTION: self.handle_ROW_DESCRIPTION,
            ERROR_RESPONSE: self.handle_ERROR_RESPONSE,
            EMPTY_QUERY_RESPONSE: self.handle_EMPTY_QUERY_RESPONSE,
            DATA_ROW: self.handle_DATA_ROW,
            COMMAND_COMPLETE: self.handle_COMMAND_COMPLETE,
            PARSE_COMPLETE: self.handle_PARSE_COMPLETE,
            BIND_COMPLETE: self.handle_BIND_COMPLETE,
            CLOSE_COMPLETE: self.handle_CLOSE_COMPLETE,
            PORTAL_SUSPENDED: self.handle_PORTAL_SUSPENDED,
            NO_DATA: self.handle_NO_DATA,
            PARAMETER_DESCRIPTION: self.handle_PARAMETER_DESCRIPTION,
            NOTIFICATION_RESPONSE: self.handle_NOTIFICATION_RESPONSE,
            COPY_DONE: self.handle_COPY_DONE,
            COPY_DATA: self.handle_COPY_DATA,
            COPY_IN_RESPONSE: self.handle_COPY_IN_RESPONSE,
            COPY_OUT_RESPONSE: self.handle_COPY_OUT_RESPONSE}


        self.send_startup()

    def new_portal(self):
        self.next_unique_id += 1
        portal = 'C_{idx}'.format(idx=self.next_unique_id)
        return portal

    def new_stmt(self):
        self.next_unique_id += 1
        stmt = 'S_{idx}'.format(idx=self.next_unique_id)
        return stmt

    def handle_messages(self, cursor):
        code = self.error = None

        while code != READY_FOR_QUERY:
            code, data_len = dt.ci_unpack(self._c._read(5))
            logger.debug("Recv code: %s, Len: %d", code, data_len)
            self.message_handles[code](self._c._read(data_len - 4), cursor)

            if self.error is not None:
                raise self.error 

    def execute(self, cursor, sql, parameters=None, flags=0):
        if not parameters:
            params = []
        else:
            params = dt.make_params(parameters)

        self.send_one_query(cursor, sql, params, flags=flags)

    def executemany(self, cursor, sql, bulk):
        if len(bulk) == 0:
            return self.execute(cursor, sql)

        parameters = bulk[0]
        params = dt.make_params(parameters)
        stmt = 'S_1'
        self.send_parse(sql, params, 0, stmt)

        for parameters in  bulk:
            params = dt.make_params(parameters)
            self.send_bind(stmt=stmt, params=params)
            self.send_execute('', 0) 
        self.send_sync()

        self.handle_messages(cursor)

    def execute_portal(self, cursor):
        cursor._ready_for_query = False
        self.send_execute(cursor.portal, cursor.arraysize) 
        self.send_sync() 
        self.handle_messages(cursor)

    def close(self, cursor):
        self.send_close(portal=cursor.portal)

    def send_startup(self):
        user = self._c.user.encode('utf8')
        password = self._c.password
        msg = protocol.build_startup_msg({b'user': user})
        self._c._write(msg)
        self._c._flush()

        self.handle_messages(None)

    def send_one_query(self, cursor, query, params, max_rows=0, fetch_size=0, flags=0):
        encode_query = query.encode('utf8')

        stmt = self.send_parse(query, params, 0)

        portal = self.new_portal()
        cursor.portal = portal

        self.send_bind(portal=portal, params=params)

        self.send_describe_portal(portal)

        cursor._row_count = -1
        self.send_execute(portal, cursor.arraysize) 
        self.send_sync() 
        self.handle_messages(cursor)
        #self.send_close(portal=portal)

    def send_simple_query(self, cursor, query, params):
        encode_query = query.encode('utf8')

        msg = protocol.build_query_msg(encode_query)
        self._c._write(msg)

        self.handle_messages(cursor)

    def send_parse(self, query, params, one_shot, stmt=''):
        logger.debug('FE->send_parse: %s, one_shot: %d', query, one_shot)
        query = query.encode('utf8')

        msg = protocol.build_parse_msg(stmt=stmt, query=query, params=params)
        self._c._write(msg)


    def send_bind(self, portal='', stmt='', params=[]):
        logger.debug('FE->send_bind: portal: %s, stmt: %s', portal, stmt)
        msg = protocol.build_bind_msg(portal, stmt, params)
        self._c._write(msg) 

    def send_sync(self):
        logger.debug('FE->send_sync')
        msg = protocol.build_sync_msg()
        self._c._write(msg) 
        self._c._flush()

    def send_describe_portal(self, portal):
        logger.debug('FE->send_describe_portal: portal: %s', portal)
        msg = protocol.build_describe_portal(portal)
        self._c._write(msg)

    def send_execute(self, portal, max_rows):
        logger.debug('FE->send_execute portal: %s, max_rows: %d', portal, max_rows)
        msg = protocol.build_execute_msg(portal, max_rows)
        self._c._write(msg) 

    def send_close(self, portal=None, stmt=None):
        logger.debug('FE-send_close portal: %s', portal)
        if portal is not None:
            msg = protocol.build_close_portal(portal)
        elif stmt is not None:
            msg = protocol.build_close_stmt(stmt)
        else:
            raise InternalError('must special the name of portal or stmt to close')

        self._c._write(msg)

    def send_terminate(self):
        logger.debug('FE-send_terminate')
        msg = protocol.build_terminate_msg()

    def flush(self):
        self._c._flush()

    def handle_NOTICE_RESPONSE(self, data, cursor):
        pass

    def handle_AUTHENTICATION_REQUEST(self, data, cursor):
        auth_code = dt.i_unpack(data)[0]
        if auth_code == 0:
            logger.debug('AuthenticationOk')

    def handle_PARAMETER_STATUS(self, data, cursor):
        logger.debug('PARAMETER_STATUS')

        
    def handle_BACKEND_KEY_DATA(self, data, ps):
        logger.debug('BACKEND_KEY_DATA')
        pass

    def handle_READY_FOR_QUERY(self, data, ps):
        # Byte1 -   Status indicator.
        logger.debug("READY_FOR_QUERY: %s", data)
        self._c.in_transaction = data != IDLE
        self._c.ready_for_query = True

    def handle_ROW_DESCRIPTION(self, data, cursor):
        
        count = dt.h_unpack(data)[0]
        idx = 2
        cursor.ps['row_desc'] = []

        for i in range(count):
            name = data[idx:data.find(NULL_BYTE, idx)]
            idx += len(name) + 1
            field = dict(
                zip(( "table_oid", "column_attrnum", "type_oid", "type_size",
                    "type_modifier", "format"), 
                    dt.ihihih_unpack(data, idx)))

            field['name'] = name
            logger.debug('ROW_DESCRIPTION: %s', field)
            idx += 18
            field['fc_type'], field['func'] = dt.pg_types[field['type_oid']]
            cursor.ps['row_desc'].append(field)

        # We've got row_desc that allows us to identify what we're  going to get back from this statement.
        cursor.ps['input_funcs'] = tuple(f['func'] for f in cursor.ps['row_desc'])


    def handle_ERROR_RESPONSE(self, data, cursor):
        msg = OrderedDict(
            (s[:1], s[1:].decode('utf8')) for s in
            data.split(NULL_BYTE) if s != b(''))
        exc_args = itervalues(msg)
        if msg[RESPONSE_CODE] == "28000":
            self.error = InterfaceError(*exc_args)
        else:
            self.error = ProgrammingError(*exc_args)

    def handle_EMPTY_QUERY_RESPONSE(self, data, ps):
        pass

    def handle_DATA_ROW(self, data, cursor):
        data_idx = 2
        row = []

        #if logger.isEnabledFor(logging.DEBUG):
        #logger.debug("DATA ROW: %s ", binascii.b2a_qp(data))

        for field in cursor.ps['row_desc']:
            func = field['func']
            vlen = dt.i_unpack(data, data_idx)[0]
            data_idx += 4
            if vlen == -1:
                row.append(None)
            else:
                row.append(func(data, data_idx, vlen))
                data_idx += vlen
        cursor._cached_rows.append(row) 

    def handle_COMMAND_COMPLETE(self, data, cursor):
        values = data[:-1].split(BINARY_SPACE)
        command = values[0]
        if command in _commands_with_count:
            row_count = int(values[-1])
            if cursor._row_count == -1:
                cursor._row_count = row_count
            else:
                cursor._row_count += row_count
            logger.debug('COMMAND_COMPLETE: %s, row_count: %d', command, row_count)

        if cursor._portal_suspended:
            cursor._portal_suspended = False
            self.send_sync()
            #处理SYNC的返回消息
            self.handle_messages(cursor)


    def handle_PARSE_COMPLETE(self, data, ps):
        logger.debug('PARSE_COMPLETE')

    def handle_BIND_COMPLETE(self, data, ps):
        logger.debug('BIND_COMPLETE')
        pass

    def handle_CLOSE_COMPLETE(self, data, ps):
        pass

    def handle_PORTAL_SUSPENDED(self, data, cursor):
        '''
        收到此消息时表示portal的max_rows已达到，需要重新发送execute + sync
        '''
        logger.debug('PORTAL_SUSPENDED')
        cursor._portal_suspended = True

    def handle_NO_DATA(self, data, ps):
        pass

    def handle_PARAMETER_DESCRIPTION(self, data, ps):
        pass

    def handle_NOTIFICATION_RESPONSE(self, data, ps):
        pass

    def handle_COPY_DONE(self, data, ps):
        pass

    def handle_COPY_DATA(self, data, ps):
        pass

    def handle_COPY_IN_RESPONSE(self, data, ps):
        pass

    def handle_COPY_OUT_RESPONSE(self, data, pas):
        pass

