#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import unicode_literals

from collections import deque, defaultdict, OrderedDict
from warnings import warn
import socket
from struct import pack
from hashlib import md5
from decimal import Decimal
from six import (b, text_type, u, binary_type, itervalues, integer_types)
from itertools import islice

from query_executor import QueryExecutor
from error import (Error, InterfaceError, DatabaseError, OperationalError, 
        NotSupportedError, IntegrityError, InternalError, 
        ProgrammingError,  NotSupportedError)

from distutils.version import StrictVersion


class Connection(object):
    # DBAPI Extension: supply exceptions as attributes on the connection
    Warning = property(lambda self: self._getError(Warning))
    Error = property(lambda self: self._getError(Error))
    InterfaceError = property(lambda self: self._getError(InterfaceError))
    DatabaseError = property(lambda self: self._getError(DatabaseError))
    OperationalError = property(lambda self: self._getError(OperationalError))
    IntegrityError = property(lambda self: self._getError(IntegrityError))
    InternalError = property(lambda self: self._getError(InternalError))
    ProgrammingError = property(lambda self: self._getError(ProgrammingError))
    NotSupportedError = property(lambda self: self._getError(NotSupportedError))


    def _getError(self, error):
        warn( "DB-API extension connection.%s used" % error.__name__, stacklevel=3)
        return error

    def __init__(self, user, host, port, database, password, ssl, timeout, application_name):
        self._sock = None
        self._client_encoding = "utf8"
        self.notifications = deque(maxlen=100)
        self.notices = deque(maxlen=100)
        self.parameter_statuses = deque(maxlen=100)
        self.lowest_server_version = self._lowest_server_version()
        
        if user is None:
            raise InterfaceError("The 'user' connection parameter cannot be None")


        if isinstance(user, text_type):
            self.user = user.encode('utf8')
        else:
            self.user = user

        if isinstance(password, text_type):
            self.password = password.encode('utf8')
        else:
            self.password = password

        self.autocommit = False
        self._xid = None

        self._caches = defaultdict(lambda: defaultdict(dict))
        self.statement_number = 0

        try:

            if host is not None:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.connect((host, port))
                self._sock = sock.makefile(mode="rwb")
            else:
                raise ProgrammingError("host must be provided")

        except socket.error as e:
            raise InterfaceError("communication error", e)

        self._flush = self._sock.flush
        self._read = self._sock.read
        self._write = self._sock.write
        self._backend_key_data = None
        self.in_transaction = False

        self._executor = QueryExecutor(self)

    def cursor(self):
        return Cursor(self)

    def execute(self, cursor, stmt, args, flags=0):
        self._executor.execute(cursor, stmt, args, flags)

    def executemany(self, cursor, stmt, bulk):
        self._executor.executemany(cursor, stmt, bulk)

    def _lowest_server_version(self):
        return StrictVersion('2.2.0')

    def close(self):
        if self._sock and not self._sock.closed:
            self._sock.close()

    def commit(self):
        pass

    def rollback(self):
        pass


class Cursor():
    def __init__(self, connection):
        self._c = connection
        self.arraysize = 1000
        self.ps = { 'statement_name_bin': None, 'row_desc': [], 
                'param_funcs': None }
        self._row_count = -1
        self._cached_rows = deque()
        self._portal_suspended = False
        self._ready_for_query = True
        self.lastrowid = None

    def execute(self, operation, parameters=None, flags=None):
        self.ps = { 'statement_name_bin': None, 'row_desc': [], 
                'param_funcs': None }
        self._row_count = -1
        self._cached_rows = deque()
        self._portal_suspended = False

        if flags is None:
            flags = QueryExecutor.QUERY_ONESHOT

        try:
            self._c.execute(self, operation, parameters, flags=flags)
        except AttributeError as e:
            if self._c is None:
                raise InterfaceError("Cursor closed")
            elif self._c._sock is None:
                raise InterfaceError("connection is closed")
            else:
                raise e

    def executemany(self, operation, seq_of_parameters):
        rowcounts = []
        self._c.executemany(self, operation, seq_of_parameters)
        #rowcounts.append(self._row_count)

        #self._row_count = -1 if -1 in rowcounts else sum(rowcounts) 

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    @property
    def connection(self):
        warn("DB-API extension cursor.connection used", stacklevel=3)
        return self._c

    @property
    def rowcount(self):
        return self._row_count

    description = property(lambda self: self._getDescription())

    def _getDescription(self):
        #print self.ps
        if self.ps is None:
            return None
        row_desc = self.ps['row_desc']
        if len(row_desc) == 0:
            return None
        columns = []
        for col in row_desc:
            columns.append(
                (col["name"], col["type_oid"], None, None, None, None, None))
        return columns

    def fetchone(self):
        """Fetch the next row of a query result set.

        This method is part of the `DBAPI 2.0 specification
        <http://www.python.org/dev/peps/pep-0249/>`_.

        :returns:
            A row as a sequence of field values, or ``None`` if no more rows
            are available.
        """
        try:
            return next(self)
        except StopIteration:
            return None
        except TypeError:
            raise ProgrammingError("attempting to use unexecuted cursor")
        except AttributeError:
            raise ProgrammingError("attempting to use unexecuted cursor")

    def fetchmany(self, num=None):
        """Fetches the next set of rows of a query result.

        This method is part of the `DBAPI 2.0 specification
        <http://www.python.org/dev/peps/pep-0249/>`_.

        :param size:

            The number of rows to fetch when called.  If not provided, the
            :attr:`arraysize` attribute value is used instead.

        :returns:

            A sequence, each entry of which is a sequence of field values
            making up a row.  If no more rows are available, an empty sequence
            will be returned.
        """
        try:
            return tuple(islice(self, self.arraysize if num is None else num))
        except TypeError:
            raise ProgrammingError("attempting to use unexecuted cursor")

    def fetchall(self):
        """Fetches all remaining rows of a query result.

        This method is part of the `DBAPI 2.0 specification
        <http://www.python.org/dev/peps/pep-0249/>`_.

        :returns:

            A sequence, each entry of which is a sequence of field values
            making up a row.
        """
        try:
            return tuple(self)
        except TypeError:
            raise ProgrammingError("attempting to use unexecuted cursor")

    def close(self):
        """Closes the cursor.

        This method is part of the `DBAPI 2.0 specification
        <http://www.python.org/dev/peps/pep-0249/>`_.
        """
        #self._c._executor.close(self)
        self._c = None

    def __iter__(self):
        """A cursor object is iterable to retrieve the rows from a query.

        This is a DBAPI 2.0 extension.
        """
        return self

    def next(self):
        try:
            if self._portal_suspended and len(self._cached_rows) == 0:
                self._c._executor.execute_portal(self)
            return self._cached_rows.popleft()
        except IndexError:
            if self.ps is None:
                raise ProgrammingError("A query hasn't been issued.")
            elif len(self.ps['row_desc']) == 0:
                raise ProgrammingError("no result set")
            else:
                raise StopIteration()

    __next__ = next
